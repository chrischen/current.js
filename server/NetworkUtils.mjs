// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.mjs";
import * as Core__Promise from "@rescript/core/src/Core__Promise.mjs";
import * as RelaySSRUtils from "./RelaySSRUtils.mjs";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as WebFetch from "@remix-run/web-fetch";
import * as RelayRouter__NetworkUtils from "./RelayRouter__NetworkUtils.mjs";

function preloadFromResponse(part, preloadAsset) {
  var obj = Js_json.decodeObject(part);
  if (obj === undefined) {
    return ;
  }
  var extensions = Caml_option.valFromOption(obj)["extensions"];
  if (extensions === undefined) {
    return ;
  }
  var extensions$1 = Js_json.decodeObject(extensions);
  if (extensions$1 !== undefined) {
    Core__Option.getOr(Core__Option.map(Caml_option.valFromOption(extensions$1)["preloadableImages"], (function (images) {
                  return Core__Array.filterMap(Core__Option.getOr(Js_json.decodeArray(images), []), Js_json.decodeString);
                })), []).forEach(function (imgUrl) {
          preloadAsset("Default", {
                TAG: "Image",
                url: imgUrl
              });
        });
    return ;
  }
  
}

function sequence(xs) {
  return Core__Array.filterMap(xs, (function (x) {
                return x;
              }));
}

var OptionArray = {
  sequence: sequence
};

var GraphQLIncrementalResponse = {};

function mapIncrementalWithDefault(t, withIncremental, $$default) {
  if (t.TAG === "Incremental") {
    return withIncremental(t._0);
  } else {
    return $$default(t._0);
  }
}

function fromIncremental(data) {
  return {
          TAG: "Incremental",
          _0: data
        };
}

function makeResponse(data) {
  return {
          TAG: "Response",
          _0: data
        };
}

function parse(json, parseFn) {
  var dict = Js_json.decodeObject(json);
  if (dict === undefined) {
    return ;
  }
  var dict$1 = Caml_option.valFromOption(dict);
  var data = Js_dict.get(dict$1, "incremental");
  if (data !== undefined) {
    var arrayData = Js_json.decodeArray(data);
    if (arrayData !== undefined) {
      return Core__Option.flatMap(sequence(arrayData.map(parseFn)), (function (data) {
                    return {
                            TAG: "Incremental",
                            _0: {
                              incremental: data,
                              hasNext: Core__Option.mapOr(Js_dict.get(dict$1, "hasNext"), false, (function (v) {
                                      return Core__Option.mapOr(Js_json.decodeBoolean(v), false, (function (v) {
                                                    return v;
                                                  }));
                                    }))
                            }
                          };
                  }));
    }
    var data$1 = parseFn(json);
    if (data$1 !== undefined) {
      return {
              TAG: "Response",
              _0: Caml_option.valFromOption(data$1)
            };
    } else {
      return ;
    }
  }
  var data$2 = parseFn(json);
  if (data$2 !== undefined) {
    return {
            TAG: "Response",
            _0: Caml_option.valFromOption(data$2)
          };
  }
  
}

function fromJson(json) {
  var dict = Js_json.decodeObject(json);
  if (dict === undefined) {
    return {
            TAG: "Response",
            _0: json
          };
  }
  var dict$1 = Caml_option.valFromOption(dict);
  var data = Js_dict.get(dict$1, "incremental");
  if (data === undefined) {
    return {
            TAG: "Response",
            _0: json
          };
  }
  var arrayData = Js_json.decodeArray(data);
  if (arrayData !== undefined) {
    return {
            TAG: "Incremental",
            _0: {
              incremental: arrayData,
              hasNext: Core__Option.mapOr(Js_dict.get(dict$1, "hasNext"), false, (function (v) {
                      return Core__Option.mapOr(Js_json.decodeBoolean(v), false, (function (v) {
                                    return v;
                                  }));
                    }))
            }
          };
  } else {
    return {
            TAG: "Response",
            _0: json
          };
  }
}

var GraphQLResponse = {
  mapIncrementalWithDefault: mapIncrementalWithDefault,
  fromIncremental: fromIncremental,
  makeResponse: makeResponse,
  parse: parse,
  fromJson: fromJson
};

function fromIncrementalResponse(param) {
  var hasNext = param.hasNext;
  var incremental = param.incremental;
  return incremental.map(function (data, i) {
              var hasNext$1 = i === (incremental.length - 1 | 0) ? hasNext : true;
              return Object.assign(data, {
                          hasNext: hasNext$1,
                          extensions: {
                            is_final: !hasNext$1
                          }
                        });
            });
}

function fromJsonIncrementalResponse(param) {
  var hasNext = param.hasNext;
  var incremental = param.incremental;
  return incremental.map(function (data, i) {
              var hasNext$1 = i === (incremental.length - 1 | 0) ? hasNext : true;
              return Object.assign({}, data, {
                          hasNext: hasNext$1,
                          extensions: {
                            is_final: !hasNext$1
                          }
                        });
            });
}

var RelayDeferResponse = {
  fromIncrementalResponse: fromIncrementalResponse,
  fromJsonIncrementalResponse: fromJsonIncrementalResponse
};

function adaptJsonIncrementalResponseToRelay(part) {
  return mapIncrementalWithDefault(fromJson(part), fromJsonIncrementalResponse, (function (part) {
                return [part];
              }));
}

function makeFetchQuery() {
  return RelaySSRUtils.makeClientFetchFunction(function (sink, operation, variables, _cacheConfig, _uploads) {
              fetch(import.meta.env.DEV ? Core__Option.getOr(import.meta.env.VITE_API_ENDPOINT, "http://localhost:4555/graphql") : "/graphql", {
                      method: "POST",
                      credentials: "include",
                      headers: Js_dict.fromArray([[
                              "content-type",
                              "application/json"
                            ]]),
                      body: Core__Option.getOr(JSON.stringify({
                                query: operation.text,
                                variables: variables
                              }), "")
                    }).then(function (r) {
                    return RelayRouter__NetworkUtils.getChunks(r, (function (part) {
                                  adaptJsonIncrementalResponseToRelay(part).map(sink.next);
                                }), (function (err) {
                                  sink.error(err);
                                }), (function () {
                                  sink.complete(undefined);
                                }));
                  });
            });
}

function makeServerFetchQuery(onQuery, headers) {
  return RelaySSRUtils.makeServerFetchFunction(onQuery, (function (sink, operation, variables, _cacheConfig, _uploads) {
                Core__Promise.$$catch(WebFetch.fetch(Core__Option.getOr(import.meta.env.VITE_API_ENDPOINT, "http://localhost:4555/graphql"), {
                            method: "POST",
                            headers: headers,
                            body: Core__Option.getOr(JSON.stringify({
                                      query: operation.text,
                                      variables: variables
                                    }), "")
                          }).then(function (r) {
                          return RelayRouter__NetworkUtils.getChunks(r, (function (part) {
                                        adaptJsonIncrementalResponseToRelay(part).map(sink.next);
                                      }), (function (err) {
                                        sink.error(err);
                                      }), (function () {
                                        sink.complete(undefined);
                                      }));
                        }), (function (e) {
                        return Promise.resolve((Core__Option.map(Caml_js_exceptions.as_js_exn(e), sink.error), undefined));
                      }));
              }));
}

export {
  preloadFromResponse ,
  OptionArray ,
  GraphQLIncrementalResponse ,
  GraphQLResponse ,
  RelayDeferResponse ,
  adaptJsonIncrementalResponseToRelay ,
  makeFetchQuery ,
  makeServerFetchQuery ,
}
/* RelaySSRUtils Not a pure module */
