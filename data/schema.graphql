"""
Directs the executor to defer this fragment when the `if` argument is true or undefined.
"""
directive @defer(
  """Deferred when true or undefined."""
  if: Boolean! = true

  """Unique name"""
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
Directs the executor to stream plural fields when the `if` argument is true or undefined.
"""
directive @stream(
  """Stream when true or undefined."""
  if: Boolean! = true

  """Number of items to return immediately"""
  initialCount: Int = 0

  """Unique name"""
  label: String
) on FIELD

input CreateEventInput {
  details: String
  endDate: Datetime!
  locationId: ID!
  startDate: Datetime!
  title: String!
}

input CreateLocationInput {
  address: String!
  details: String
  links: [String!]
  name: String!
}

"""A date."""
scalar Datetime

type Error {
  message: String!
}

type Event implements Node {
  details: String
  endDate: Datetime
  id: ID!
  location: Location
  owner: User
  rsvps(after: String, before: String, first: Int): EventRsvpConnection
  startDate: Datetime
  title: String
}

"""A connection to users."""
type EventConnection {
  """A list of edges."""
  edges: [EventEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge to a user."""
type EventEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Event
}

"""A connection to users."""
type EventRsvpConnection {
  """A list of edges."""
  edges: [EventRsvpEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge to a user."""
type EventRsvpEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Rsvp
}

interface HasErrors {
  errors: [Error!]
}

type JoinEventResult implements HasErrors {
  edge: EventRsvpEdge
  errors: [Error!]
}

type LeaveEventResult implements HasErrors {
  errors: [Error!]
  eventIds: [ID!]
}

type Location implements Node {
  active: Boolean
  address: String
  details: String
  id: ID!
  links: [String!]
  name: String
}

"""A connection to users."""
type LocationConnection {
  """A list of edges."""
  edges: [LocationEdge]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
}

"""An edge to a user."""
type LocationEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Location
}

type Mutation {
  createEvent(input: CreateEventInput!): MutationResult2!
  createLocation(input: CreateLocationInput!): MutationResult!
  joinEvent(eventId: ID!): JoinEventResult!
  leaveEvent(eventId: ID!): LeaveEventResult!
}

type MutationResult implements HasErrors {
  errors: [Error!]
  location: Location
}

type MutationResult2 implements HasErrors {
  errors: [Error!]
  event: Event
}

interface Node {
  id: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type Query {
  """The current time on the server, as a timestamp."""
  currentTime: Float

  """Delayed current time to test @defer and streaming."""
  currentTime2: Float
  event(id: ID!): Event
  events(after: String, before: String, first: Int): EventConnection!
  location(id: ID!): Location
  locations(after: String, before: String, first: Int): LocationConnection!
  node(id: ID!): Node
  viewer: Viewer
}

type Rsvp implements Node {
  id: ID!
  joinTime: Int
  leaveDate: Datetime
  user: User
}

type User implements Node {
  id: ID!
  lineUsername: String
  rating: Int
}

type Viewer {
  event(id: ID!): Event
  user: User
}